# λ¦¬ν©ν† λ§ ν¬μΈνΈ μ”μ•½

μ”κµ¬μ‚¬ν•­.txt νμΌμ— λ…μ‹λ λ¦¬ν©ν† λ§ ν¬μΈνΈλ¥Ό μ •λ¦¬ν• λ¬Έμ„μ…λ‹λ‹¤.

## π“‹ μ£Όμ” λ¦¬ν©ν† λ§ ν¬μΈνΈ

### 1. I/O μΈν„°νμ΄μ¤ μ¶”μƒν™” (ν΄λμ¤ κΈ°λ°)

**λ©μ **: ROSμ™€ Tiki ν™κ²½ λ¨λ‘μ— λ€μ‘ν•λ” ν”λ«νΌ λ…λ¦½μ μΈ κµ¬μ΅°

**κµ¬ν„ λ°©μ•**:
- μ¶”μƒ μΈν„°νμ΄μ¤ ν΄λμ¤ μ •μ (`interface/` λ””λ ‰ν† λ¦¬)
  - `MotorInterface`: λ¨ν„° μ μ–΄ μ¶”μƒν™”
  - `CameraInterface`: μΉ΄λ©”λΌ μ΄λ―Έμ§€ μΊ΅μ² μ¶”μƒν™”
  - `DisplayInterface`: OLED/λ΅κ·Έ μ¶λ ¥ μ¶”μƒν™”
  - `LEDInterface`: LED μ μ–΄ μ¶”μƒν™”
  - `IMUInterface`: IMU μ„Όμ„ λ°μ΄ν„° μ¶”μƒν™”

- ν”λ«νΌλ³„ κµ¬ν„μ²΄ (`platform/ros/`, `platform/tiki/`)
  - ROS ν™κ²½: `ROSMotorController`, `ROSCamera`, `ROSDisplay` λ“±
  - Tiki ν™κ²½: `TikiMotorController`, `TikiCamera`, `TikiDisplay` λ“±

**μ μ© ν¨ν„΄**: Adapter ν¨ν„΄

**μμ‹ κµ¬μ΅°**:
```
interface/
β”β”€β”€ motor_interface.py
β”β”€β”€ camera_interface.py
β”β”€β”€ display_interface.py
β”β”€β”€ led_interface.py
β””β”€β”€ imu_interface.py

platform/
β”β”€β”€ ros/
β”‚   β”β”€β”€ ros_motor_controller.py
β”‚   β”β”€β”€ ros_camera.py
β”‚   β””β”€β”€ ...
β””β”€β”€ tiki/
    β”β”€β”€ tiki_motor_controller.py
    β”β”€β”€ tiki_camera.py
    β””β”€β”€ ...
```

---

### 2. κΈ°λ¥ ν•¨μ λ¶„λ¦¬ (λ¨λ“ν™”)

**λ©μ **: ν΄λμ¤ μ½”λ“ κ°„κ²°ν™” λ° μ¬μ‚¬μ©μ„± ν–¥μƒ

**λ¶„λ¦¬ λ€μƒ ν•¨μλ“¤**:

#### 2.1 ν¬νΈν™€ κ°μ§€ ν•¨μ
- **ν•¨μλ…**: `check_binary_image_pothole(bin_img: np.ndarray) -> bool`
- **μ„μΉ**: `src/utils/detection_utils.py` λλ” `src/utils/pothole_utils.py`
- **κΈ°λ¥**: μ΄μ§„ν™”λ μμƒμ—μ„ ν¬νΈν™€ κ°μ§€ λ΅μ§ λ¶„λ¦¬

#### 2.2 λ§μ»¤ μ ν¨μ„± νλ‹¨ ν•¨μ
- **ν•¨μλ…**: `is_valid_marker(ids: list[int], last_detect_time: float) -> bool`
- **μ„μΉ**: `src/utils/marker_utils.py`
- **κΈ°λ¥**: ArUco λ§μ»¤ ID μ ν¨μ„± κ²€μ‚¬ λ° μ¤‘λ³µ κ°μ§€ λ°©μ§€

#### 2.3 μ΄λ―Έμ§€ μ €μ¥ ν•¨μ
- **ν•¨μλ…**: `save_image(img: np.ndarray, prefix: str = "") -> str`
- **μ„μΉ**: `src/utils/image_utils.py`
- **κΈ°λ¥**: νμΌ κ²½λ΅ μƒμ„±, λ””λ ‰ν† λ¦¬ μƒμ„±, μ΄λ―Έμ§€ μ €μ¥ μΊ΅μν™”

#### 2.4 νμ „ μ‹κ°„ κ³„μ‚° ν•¨μ
- **ν•¨μλ…**: `compute_turn_duration(angle_deg: float, speed: float) -> float`
- **μ„μΉ**: `src/utils/motion_utils.py`
- **κΈ°λ¥**: νμ „ κ°λ„μ™€ μ†λ„λ΅λ¶€ν„° ν•„μ”ν• νμ „ μ‹κ°„ κ³„μ‚°

#### 2.5 μΊ΅μ² μ΅°κ±΄ μ²΄ν¬ ν•¨μ
- **ν•¨μλ…**: `should_capture_frame(frame_index: int, last_capture_index: int, interval: int = 30) -> bool`
- **μ„μΉ**: `src/utils/image_utils.py` λλ” `src/utils/capture_utils.py`
- **κΈ°λ¥**: ν”„λ μ„ κ°„κ²© κΈ°λ° μΊ΅μ² μ΅°κ±΄ νλ‹¨

**μ¶”κ°€ λ¶„λ¦¬ κ°€λ¥ ν•¨μλ“¤**:
- `detect_aruco_markers(frame) -> (corners, ids)`: ArUco λ§μ»¤ κ²€μ¶
- `get_lane_mask(frame) -> np.ndarray`: μ°¨μ„  λ§μ¤ν¬ μƒμ„±
- `detect_lane_curve(mask) -> float`: μ°¨μ„  κ³΅λ¥  κ³„μ‚°
- `detect_offset(mask) -> float`: μ°¨μ„  μ¤‘μ•™ μ¤ν”„μ…‹ κ³„μ‚°

---

### 3. ν•µμ‹¬ ν΄λμ¤ λ‹¨μν™” λ° μ—­ν•  λ¶„λ¦¬

#### 3.1 ArucoTrigger ν΄λμ¤
**ν„μ¬ λ¬Έμ μ **:
- ν•λ“μ›¨μ–΄ μ μ–΄ λ΅μ§μ΄ ν΄λμ¤ λ‚΄λ¶€μ— μ§μ ‘ ν¬ν•¨
- μ΄λ―Έμ§€ μ €μ¥, LED μ μ–΄ λ“± μ„Έλ¶€ κµ¬ν„μ΄ νΌμ¬

**λ¦¬ν©ν† λ§ ν›„**:
- **μƒνƒ κ΄€λ¦¬λ§ μ§‘μ¤‘**: λ§μ»¤ ID, μ‹κ°„, μΊ΅μ² μ‹μ  λ“±
- **I/O μμ΅΄μ„± μ£Όμ…**: `CameraInterface`, `LEDInterface`, `DisplayInterface` μ£Όμ…
- **λ΅μ§ μ„μ„**: λ§μ»¤ κ²€μ¶μ€ `detect_aruco_markers()`, μ ν¨μ„± νλ‹¨μ€ `is_valid_marker()`, μ΄λ―Έμ§€ μ €μ¥μ€ `save_image()` λ“±μΌλ΅ μ„μ„

**μμ‹ κµ¬μ΅°**:
```python
class ArucoTrigger:
    def __init__(self, camera_interface, led_interface, display_interface):
        self.camera = camera_interface
        self.led = led_interface
        self.display = display_interface
        # μƒνƒλ§ κ΄€λ¦¬
        self.last_marker_id = None
        self.last_capture_time = 0.0
    
    def process_frame(self, frame):
        corners, ids = detect_aruco_markers(frame)  # μ ν‹Έ ν•¨μ νΈμ¶
        if is_valid_marker(ids, self.last_marker_time):  # μ ν‹Έ ν•¨μ νΈμ¶
            self.display.log("λ§μ»¤ κ°μ§€")
            if should_capture_frame(...):  # μ ν‹Έ ν•¨μ νΈμ¶
                save_image(frame, "aruco")  # μ ν‹Έ ν•¨μ νΈμ¶
```

#### 3.2 Controller ν΄λμ¤
**λ¦¬ν©ν† λ§ ν›„**:
- **I/O μμ΅΄μ„± μ£Όμ…**: `MotorInterface`, `IMUInterface` μ£Όμ…
- **λ΅μ§ μ„μ„**: νμ „ μ‹κ°„ κ³„μ‚°μ€ `compute_turn_duration()`, λ¨ν„° μ μ–΄λ” `motor.set_speed()` λ“±μΌλ΅ μ„μ„
- **μƒνƒ κ΄€λ¦¬ μ§‘μ¤‘**: μ£Όν–‰ λ¨λ“, λ©ν‘ μ†λ„ λ“±

#### 3.3 LaneDetector ν΄λμ¤
**λ¦¬ν©ν† λ§ ν›„**:
- **μ΄λ―Έμ§€ μ²λ¦¬ μ„μ„**: `get_lane_mask()`, `detect_lane_curve()`, `detect_offset()` λ“±μΌλ΅ μ„μ„
- **ν¬νΈν™€ κ°μ§€ μ„μ„**: `check_binary_image_pothole()` ν•¨μ νΈμ¶
- **κ²°μ • λ΅μ§λ§ μ μ§€**: μ°¨μ„  μ¤ν”„μ…‹ κΈ°λ° μ μ–΄ λ…λ Ή κ²°μ •

---

### 4. λ””μμΈ ν¨ν„΄ μ μ©

#### 4.1 Adapter ν¨ν„΄
- **μ μ© μ„μΉ**: I/O μΈν„°νμ΄μ¤ μ¶”μƒν™” μ „λ°
- **λ©μ **: ROS APIμ™€ Tiki APIλ¥Ό ν†µμΌλ μΈν„°νμ΄μ¤λ΅ λ³€ν™

#### 4.2 Strategy ν¨ν„΄
- **ν™κ²½ μ„ νƒ μ „λµ**: ROS/Tiki λ¨λ“μ— λ”°λ¥Έ I/O λ°”μΈλ”© μ„ νƒ
- **μ•κ³ λ¦¬μ¦ κµμ²΄**: μ°¨μ„  μΈμ‹ λ°©λ²•, μ£Όν–‰ μ μ–΄ μ •μ±… λ“±

#### 4.3 κΈ°νƒ€ κ³ λ ¤ ν¨ν„΄
- **Facade ν¨ν„΄**: Robot λ©”μΈ ν΄λμ¤κ°€ μ—¬λ¬ ν•μ„ λ¨λ“ κ΄€λ¦¬
- **Observer ν¨ν„΄**: μ΄λ²¤νΈ ν†µμ§€ κµ¬μ΅° (μ„ νƒμ )

---

### 5. λ””λ ‰ν† λ¦¬ κµ¬μ΅° κ°μ„ 

**μ μ• κµ¬μ΅°**:
```
maicon_preparation/
β”β”€β”€ interface/                    # μ¶”μƒ I/O μΈν„°νμ΄μ¤
β”‚   β”β”€β”€ motor_interface.py
β”‚   β”β”€β”€ camera_interface.py
β”‚   β”β”€β”€ display_interface.py
β”‚   β”β”€β”€ led_interface.py
β”‚   β””β”€β”€ imu_interface.py
β”β”€β”€ platform/                     # ν”λ«νΌλ³„ κµ¬ν„
β”‚   β”β”€β”€ ros/
β”‚   β”‚   β”β”€β”€ ros_motor_controller.py
β”‚   β”‚   β”β”€β”€ ros_camera.py
β”‚   β”‚   β””β”€β”€ ...
β”‚   β””β”€β”€ tiki/
β”‚       β”β”€β”€ tiki_motor_controller.py
β”‚       β”β”€β”€ tiki_camera.py
β”‚       β””β”€β”€ ...
β”β”€β”€ src/
β”‚   β”β”€β”€ core/
β”‚   β”‚   β”β”€β”€ control/
β”‚   β”‚   β”‚   β””β”€β”€ controller.py          # λ¦¬ν©ν† λ§λ¨
β”‚   β”‚   β”β”€β”€ detection/
β”‚   β”‚   β”‚   β”β”€β”€ aruco_trigger_capture_yolo.py  # λ¦¬ν©ν† λ§λ¨
β”‚   β”‚   β”‚   β””β”€β”€ lane_detector.py      # λ¦¬ν©ν† λ§λ¨
β”‚   β”‚   β””β”€β”€ ai/
β”‚   β”‚       β””β”€β”€ image_yolo.py
β”‚   β””β”€β”€ utils/                    # μ ν‹Έλ¦¬ν‹° ν•¨μλ“¤
β”‚       β”β”€β”€ image_utils.py
β”‚       β”β”€β”€ marker_utils.py
β”‚       β”β”€β”€ motion_utils.py
β”‚       β”β”€β”€ detection_utils.py
β”‚       β””β”€β”€ pothole_utils.py
β””β”€β”€ src/main/
    β””β”€β”€ robot.py                  # λ©”μΈ μ‹¤ν–‰ μ¤ν¬λ¦½νΈ
```

---

### 6. λ©”μΈ μ‹¤ν–‰ μ¤ν¬λ¦½νΈ κµ¬μ΅°

**ν™κ²½λ³„ λ¶„κΈ° μ²λ¦¬**:
```python
# robot.py
env = os.getenv("ROBOT_ENV", "ROS")

if env == "ROS":
    motor = ROSMotorController()
    camera = ROSCamera()
    display = ROSDisplay()
    led = ROSLedController()
    imu = ROSImu()
else:  # "TIKI"
    motor = TikiMotorController()
    camera = TikiCamera()
    display = TikiDisplay()
    led = TikiLedController()
    imu = TikiImu()

# μΈν„°νμ΄μ¤ μ£Όμ…
controller = Controller(motor_interface=motor, imu_interface=imu)
lane_detector = LaneDetector(camera_interface=camera, controller=controller)
aruco_trigger = ArucoTrigger(camera_interface=camera, 
                             led_interface=led, 
                             display_interface=display)
```

---

## β… λ¦¬ν©ν† λ§ ν¨κ³Ό

1. **ν”λ«νΌ λ…λ¦½μ„±**: ROS/Tiki ν™κ²½ μ „ν™ μ‹ μ½”λ“ μμ • μµμ†ν™”
2. **μ½”λ“ μ¬μ‚¬μ©μ„±**: μ ν‹Έ ν•¨μλ΅ μ¤‘λ³µ μ½”λ“ μ κ±°
3. **ν…μ¤νΈ μ©μ΄μ„±**: ν•¨μ λ‹¨μ„ ν…μ¤νΈ κ°€λ¥
4. **μ μ§€λ³΄μμ„±**: ν΄λμ¤ μ±…μ„ λ…ν™•ν™”λ΅ μμ • μ©μ΄
5. **ν™•μ¥μ„±**: μƒλ΅μ΄ ν•λ“μ›¨μ–΄ μ¶”κ°€ μ‹ μΈν„°νμ΄μ¤ κµ¬ν„λ§ μ¶”κ°€

---

## π“ μ°Έκ³ μ‚¬ν•­

- **Python 2 νΈν™μ„±**: κΈ°μ΅΄ μ½”λ“λ” Python 2 κΈ°λ°μ΄λ―€λ΅ λ¦¬ν©ν† λ§ μ‹ νΈν™μ„± κ³ λ ¤ ν•„μ”
- **μ μ§„μ  λ¦¬ν©ν† λ§**: ν• λ²μ— λ¨λ“  κ²ƒμ„ λ°”κΎΈμ§€ λ§κ³  λ‹¨κ³„μ μΌλ΅ μ§„ν–‰
- **Docstring μ¶”κ°€**: κ° ν΄λμ¤μ™€ ν•¨μμ— μ„¤λ… μ£Όμ„ μ¶”κ°€ ν•„μ
- **λ””μμΈ ν¨ν„΄ μ£Όμ„**: μ μ©λ ν¨ν„΄μ„ μ½”λ“μ— λ…μ‹

---

## π”„ λ¦¬ν©ν† λ§ μ°μ„ μμ„

1. **1λ‹¨κ³„**: μ ν‹Έ ν•¨μ λ¶„λ¦¬ (κ°€μ¥ μν–¥ μ μ)
2. **2λ‹¨κ³„**: μΈν„°νμ΄μ¤ μ •μ λ° ROS κµ¬ν„μ²΄ μ‘μ„±
3. **3λ‹¨κ³„**: ν•µμ‹¬ ν΄λμ¤ λ¦¬ν©ν† λ§ (μΈν„°νμ΄μ¤ μ£Όμ…)
4. **4λ‹¨κ³„**: Tiki κµ¬ν„μ²΄ μ‘μ„± λ° ν…μ¤νΈ
5. **5λ‹¨κ³„**: λ©”μΈ μ¤ν¬λ¦½νΈ ν†µν•© λ° μµμΆ… ν…μ¤νΈ

